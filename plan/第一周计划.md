# PyChat

计划功能

- 最基础的聊天功能
- 用户管理
- 友好的界面
- 点对点聊天
- 加密功能
- 后台监控

参考链接

## 第一周计划

服务器基本循环和最基础的发送接收

## 下一周计划

服务器向客户端们广播（broadcast）

基础的UI和多线程



## python 多线程

> 多任务可以由多进程完成，也可以由一个进程内的多线程完成。
>
> 我们前面提到了进程是由若干线程组成的，一个进程至少有一个线程。
>
> 由于线程是操作系统直接支持的执行单元，因此，高级语言通常都内置多线程的支持，Python也不例外，并且，Python的线程是真正的Posix Thread，而不是模拟出来的线程。
>
> Python的标准库提供了两个模块：`thread`和`threading`，`thread`是低级模块，`threading`是高级模块，对`thread`进行了封装。绝大多数情况下，我们只需要使用`threading`这个高级模块。



### 使用Threading模块创建线程

```python
import time, threading

# 新线程执行的代码:
def loop():
    print('thread %s is running...' % threading.current_thread().name)
    n = 0
    while n < 5:
        n = n + 1
        print('thread %s >>> %s' % (threading.current_thread().name, n))
        time.sleep(1)
    print('thread %s ended.' % threading.current_thread().name)

print('thread %s is running...' % threading.current_thread().name)
t = threading.Thread(target=loop, name='LoopThread')
t.start()
t.join()
print('thread %s ended.' % threading.current_thread().name)
```

### 线程安全 Lock

>多线程和多进程最大的不同在于，多进程中，同一个变量，各自有一份拷贝存在于每个进程中，互不影响，而多线程中，所有变量都由所有线程共享，所以，任何一个变量都可以被任何一个线程修改，因此，线程之间共享数据最大的危险在于多个线程同时改一个变量，把内容给改乱了。
>
>来看看多个线程同时操作一个变量怎么把内容给改乱了：

```python
import time, threading

# 假定这是你的银行存款:
balance = 0

def change_it(n):
    # 先存后取，结果应该为0:
    global balance
    balance = balance + n
    balance = balance - n

def run_thread(n):
    for i in range(100000):
        change_it(n)

t1 = threading.Thread(target=run_thread, args=(5,))
t2 = threading.Thread(target=run_thread, args=(8,))
t1.start()
t2.start()
t1.join()
t2.join()
print(balance)
```

#### 加锁

```python
balance = 0
lock = threading.Lock()

def run_thread(n):
    for i in range(100000):
        # 先要获取锁:
        lock.acquire()
        try:
            # 放心地改吧:
            change_it(n)
        finally:
            # 改完了一定要释放锁:
            lock.release()
```

### python 多线程的问题——全局解释器锁（GIL）

以下摘自wiki

>- CPython的线程是[操作系统](https://zh.wikipedia.org/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F)的原生线程。在[Linux](https://zh.wikipedia.org/wiki/Linux)上为pthread，在[Windows](https://zh.wikipedia.org/wiki/Windows)上为Win thread，完全由操作系统调度线程的执行。一个Python解释器进程内有一个主线程，以及多个用户程序的执行线程。即便使用[多核心CPU](https://zh.wikipedia.org/wiki/%E5%A4%9A%E6%A0%B8%E5%BF%83CPU)平台，由于GIL的存在，也将禁止多线程的并行执行。[[2\]](https://zh.wikipedia.org/wiki/%E5%85%A8%E5%B1%80%E8%A7%A3%E9%87%8A%E5%99%A8%E9%94%81#cite_note-2)
>
>- Python解释器进程内的多线程是以协作多任务方式执行。当一个线程遇到[I/O](https://zh.wikipedia.org/wiki/I/O)任务时，将释放GIL。计算密集型（CPU-bound）的线程在执行大约100次解释器的计步（ticks）时，将释放GIL。计步（ticks）可粗略看作Python虚拟机的指令。计步实际上与时间片长度无关。可以通过sys.setcheckinterval()设置计步长度。
>- 在单核CPU上，数百次的间隔检查才会导致一次线程切换。在多核CPU上，存在严重的线程颠簸（thrashing）。
>- Python 3.2开始使用新的GIL。新的GIL实现中用一个固定的超时时间来指示当前的线程放弃全局锁。在当前线程保持这个锁，且其他线程请求这个锁时，当前线程就会在5毫秒后被强制释放该锁。
>- 可以创建独立的进程来实现并行化。Python 2.6引进了多进程包multiprocessing。或者将关键组件用[C](https://zh.wikipedia.org/wiki/C%E8%AF%AD%E8%A8%80)/[C++](https://zh.wikipedia.org/wiki/C%2B%2B)编写为Python扩展，通过ctypes使Python程序直接调用C语言[编译](https://zh.wikipedia.org/wiki/%E7%BC%96%E8%AF%91)的[动态链接库](https://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93)的导出函数。

简单来说 Python最常用的解释器CPython自带锁。任何Python线程执行前，必须先获得GIL锁，然后，每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行。这个GIL全局锁实际上把所有线程的执行代码都给上了锁，所以，多线程在Python中只能交替执行，即使100个线程跑在100核CPU上，也只能用到1个核。Python在多线程里面其实是快速切换，所以想要用python写真正的多线程，只能自己实现一个解释器。

http://www.runoob.com/python/python-multithreading.html

http://www.runoob.com/python/python-socket.html

https://docs.python.org/3.6/library/threading.html#threading.Thread.setDaemon